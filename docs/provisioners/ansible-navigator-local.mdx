---
description: >
  The ansible-navigator Packer provisioner will run ansible-navigator in "local"
  mode on the remote/guest VM using Playbook and Role files that exist on the
  guest VM. This means Ansible Navigator must be installed on the remote/guest VM.
  Playbooks and Roles can be uploaded from your build machine (the one running
  Packer) to the vm.
page_title: Ansible Navigator Local - Provisioners
nav_title: Ansible Navigator Local
---

# Ansible Navigator Local Provisioner

Type: `ansible-navigator`

The `ansible-navigator` Packer provisioner will execute `ansible-navigator` in "local"
mode on the remote/guest VM using Playbook and Role files that exist on the
guest VM. This means Ansible Navigator must be installed on the remote/guest VM.
Playbooks and Roles can be uploaded from your build machine (the one running
Packer) to the vm. Ansible Navigator is then run on the guest machine in [local
mode](https://docs.ansible.com/ansible/latest/playbooks_delegation.html#local-playbooks)
via the `ansible-navigator run` command.

## About Ansible Navigator

Ansible Navigator is a command-line tool that provides a consistent interface for running Ansible content in execution environments. Unlike traditional `ansible-playbook`, ansible-navigator runs playbooks inside container-based execution environments.

**Requirements for the remote/guest VM:**
- **ansible-navigator** must be installed on the remote/guest VM
- **Docker or Podman** must be installed and running on the remote/guest VM
  - Docker: https://docs.docker.com/get-docker/
  - Podman: https://podman.io/getting-started/installation

The provisioner uses ansible-navigator to execute playbooks within execution environment containers on the guest machine, ensuring consistent Ansible versions and dependencies.

-> **Note:** Ansible will _not_ be installed automatically by this
provisioner. This provisioner expects that Ansible is already installed on the
guest/remote machine. It is common practice to use the [shell
provisioner](/packer/docs/provisioners/shell) before the Ansible provisioner to
do this.

## Basic Example

The example below is fully functional.

**HCL2**

```hcl
variable "topping" {
  type    = string
  default = "mushroom"
}

source "docker" "example" {
  image       = "williamyeh/ansible:ubuntu14.04"
  export_path = "packer_example"
  run_command = ["-d", "-i", "-t", "--entrypoint=/bin/bash", "{{.Image}}"]
}

build {
  sources = [
    "source.docker.example"
  ]

  provisioner "ansible-navigator" {
    playbook_file   = "./playbook.yml"
    extra_arguments = ["--extra-vars", "\"pizza_toppings=${var.topping}\""]
  }
}
```

**JSON**

```json
{
  "builders": [
    {
      "type": "docker",
      "image": "williamyeh/ansible:ubuntu14.04",
      "export_path": "packer_example",
      "run_command": ["-d", "-i", "-t", "--entrypoint=/bin/bash", "{{.Image}}"]
    }
  ],
  "variables": {
    "topping": "mushroom"
  },
  "provisioners": [
    {
      "type": "ansible-navigator",
      "playbook_file": "./playbook.yml",
      "extra_arguments": [
        "--extra-vars",
        "\"pizza_toppings={{ user `topping`}}\""
      ]
    }
  ]
}
```


where ./playbook.yml contains

```
---
- name: hello world
  hosts: 127.0.0.1
  connection: local

  tasks:
    - command: echo {{ pizza_toppings }}
    - debug: msg="{{ pizza_toppings }}"

```

## Configuration Reference

The reference of available configuration options is listed below.

Required:

- `playbook_file` (string) - The playbook file to be executed by ansible.
  This file must exist on your local system and will be uploaded to the
  remote machine. This option is exclusive with `playbook_files`.

- `playbook_files` (array of strings) - The playbook files to be executed by
  ansible. These files must exist on your local system. If the files don't
  exist in the `playbook_dir` or you don't set `playbook_dir` they will be
  uploaded to the remote machine. This option is exclusive with
  `playbook_file`.

Optional:

@include '/provisioner/ansible-local/Config-not-required.mdx'

@include 'provisioners/common-config.mdx'

## Advanced Examples with Plays and Collections

### Using Collection Plays Locally

Execute plays directly from collections that are installed on the guest VM:

**HCL2**

```hcl
provisioner "ansible-navigator" {
  plays = [
    {
      name = "Setup Docker Container"
      target = "community.general.docker_container"
      extra_vars = {
        container_name = "webapp"
      }
    },
    {
      name = "Configure SELinux"
      target = "ansible.posix.selinux"
      extra_vars = {
        selinux_state = "enforcing"
      }
    }
  ]
}
```

**JSON**

```json
{
  "type": "ansible-navigator",
  "plays": [
    {
      "name": "Setup Docker Container",
      "target": "community.general.docker_container",
      "extra_vars": {
        "container_name": "webapp"
      }
    },
    {
      "name": "Configure SELinux",
      "target": "ansible.posix.selinux",
      "extra_vars": {
        "selinux_state": "enforcing"
      }
    }
  ]
}
```

### Multi-Stage Local Deployment

Execute multiple collection plays in sequence on the guest VM:

**HCL2**

```hcl
provisioner "ansible-navigator" {
  plays = [
    {
      name = "Configure Hostname"
      target = "baseline.system.configure_hostname"
      extra_vars = {
        hostname = "webapp01"
      }
    },
    {
      name = "Setup Users"
      target = "baseline.system.setup_users"
    },
    {
      name = "Install Application"
      target = "app.service.install"
      extra_vars = {
        app_version = "2.1.0"
      }
    },
    {
      name = "Configure Application"
      target = "app.service.configure"
    }
  ]
  
  playbook_dir = "/tmp/ansible-local"
}
```

**JSON**

```json
{
  "type": "ansible-navigator",
  "plays": [
    {
      "name": "Configure Hostname",
      "target": "baseline.system.configure_hostname",
      "extra_vars": {
        "hostname": "webapp01"
      }
    },
    {
      "name": "Setup Users",
      "target": "baseline.system.setup_users"
    },
    {
      "name": "Install Application",
      "target": "app.service.install",
      "extra_vars": {
        "app_version": "2.1.0"
      }
    },
    {
      "name": "Configure Application",
      "target": "app.service.configure"
    }
  ],
  "playbook_dir": "/tmp/ansible-local"
}
```

### Local Execution with Custom Collection Path

Use collection plays from a custom installation path on the guest:

**HCL2**

```hcl
provisioner "ansible-navigator" {
  plays = [
    {
      name = "Deploy Application"
      target = "myorg.app.deploy"
      extra_vars = {
        deployment_type = "standalone"
      }
    },
    {
      name = "Health Check"
      target = "myorg.app.healthcheck"
      extra_vars = {
        health_check_retries = 5
      }
    }
  ]
  
  playbook_dir = "/opt/ansible"
  
  # Collections must be pre-installed on the guest VM at this path
  ansible_env_vars = [
    "ANSIBLE_COLLECTIONS_PATHS=/opt/ansible/collections"
  ]
}
```

**JSON**

```json
{
  "type": "ansible-navigator",
  "plays": [
    {
      "name": "Deploy Application",
      "target": "myorg.app.deploy",
      "extra_vars": {
        "deployment_type": "standalone"
      }
    },
    {
      "name": "Health Check",
      "target": "myorg.app.healthcheck",
      "extra_vars": {
        "health_check_retries": 5
      }
    }
  ],
  "playbook_dir": "/opt/ansible",
  "ansible_env_vars": [
    "ANSIBLE_COLLECTIONS_PATHS=/opt/ansible/collections"
  ]
}
```

### Container Orchestration on Guest

Deploy containers locally on the guest VM using collection plays:

**HCL2**

```hcl
provisioner "ansible-navigator" {
  plays = [
    {
      name = "Create Docker Network"
      target = "community.docker.docker_network"
      extra_vars = {
        network_name = "app_net"
      }
    },
    {
      name = "Create Docker Volume"
      target = "community.docker.docker_volume"
      extra_vars = {
        volume_name = "app_data"
      }
    },
    {
      name = "Start Docker Container"
      target = "community.docker.docker_container"
      extra_vars = {
        container_image = "nginx:alpine"
      }
    }
  ]
}
```

**JSON**

```json
{
  "type": "ansible-navigator",
  "plays": [
    {
      "name": "Create Docker Network",
      "target": "community.docker.docker_network",
      "extra_vars": {
        "network_name": "app_net"
      }
    },
    {
      "name": "Create Docker Volume",
      "target": "community.docker.docker_volume",
      "extra_vars": {
        "volume_name": "app_data"
      }
    },
    {
      "name": "Start Docker Container",
      "target": "community.docker.docker_container",
      "extra_vars": {
        "container_image": "nginx:alpine"
      }
    }
  ]
}
```

### Development Workflow

Quick iteration during development with verbose output:

**HCL2**

```hcl
provisioner "ansible-navigator" {
  plays = [
    {
      name = "Setup Development Environment"
      target = "dev.app.setup"
      extra_vars = {
        env = "development"
      }
    },
    {
      name = "Run Tests"
      target = "dev.app.test"
      extra_vars = {
        run_tests = true
      }
    }
  ]
  
  extra_arguments = [
    "-vvv"
  ]
  
  ansible_env_vars = [
    "ANSIBLE_STDOUT_CALLBACK=debug"
  ]
}
```

**JSON**

```json
{
  "type": "ansible-navigator",
  "plays": [
    {
      "name": "Setup Development Environment",
      "target": "dev.app.setup",
      "extra_vars": {
        "env": "development"
      }
    },
    {
      "name": "Run Tests",
      "target": "dev.app.test",
      "extra_vars": {
        "run_tests": true
      }
    }
  ],
  "extra_arguments": [
    "-vvv"
  ],
  "ansible_env_vars": [
    "ANSIBLE_STDOUT_CALLBACK=debug"
  ]
}
```

## Default Extra Variables

In addition to being able to specify extra arguments using the
`extra_arguments` configuration, the provisioner automatically defines certain
commonly useful Ansible variables:

- `packer_build_name` is set to the name of the build that Packer is running.
  This is most useful when Packer is making multiple builds and you want to
  distinguish them slightly when using a common playbook.

- `packer_builder_type` is the type of the builder that was used to create
  the machine that the script is running on. This is useful if you want to
  run only certain parts of the playbook on systems built with certain
  builders.

- `packer_http_addr` If using a builder that provides an HTTP server for file
  transfer (such as `hyperv`, `parallels`, `qemu`, `virtualbox`, and `vmware`), this
  will be set to the address. You can use this address in your provisioner to
  download large files over HTTP. This may be useful if you're experiencing
  slower speeds using the default file provisioner. A file provisioner using
  the `winrm` communicator may experience these types of difficulties.
