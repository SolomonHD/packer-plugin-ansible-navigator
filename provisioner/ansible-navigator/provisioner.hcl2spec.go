// Code generated by "packer-sdc mapstructure-to-hcl2"; DO NOT EDIT.

package ansiblenavigator

import (
	"github.com/hashicorp/hcl/v2/hcldec"
	"github.com/zclconf/go-cty/cty"
)

// FlatAnsibleConfig is an auto-generated flat version of AnsibleConfig.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatAnsibleConfig struct {
	Config        *string                      `mapstructure:"config" cty:"config" hcl:"config"`
	Defaults      *FlatAnsibleConfigDefaults   `mapstructure:"defaults" cty:"defaults" hcl:"defaults"`
	SSHConnection *FlatAnsibleConfigConnection `mapstructure:"ssh_connection" cty:"ssh_connection" hcl:"ssh_connection"`
}

// FlatMapstructure returns a new FlatAnsibleConfig.
// FlatAnsibleConfig is an auto-generated flat version of AnsibleConfig.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*AnsibleConfig) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatAnsibleConfig)
}

// HCL2Spec returns the hcl spec of a AnsibleConfig.
// This spec is used by HCL to read the fields of AnsibleConfig.
// The decoded values from this spec will then be applied to a FlatAnsibleConfig.
func (*FlatAnsibleConfig) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"config":         &hcldec.AttrSpec{Name: "config", Type: cty.String, Required: false},
		"defaults":       &hcldec.BlockSpec{TypeName: "defaults", Nested: hcldec.ObjectSpec((*FlatAnsibleConfigDefaults)(nil).HCL2Spec())},
		"ssh_connection": &hcldec.BlockSpec{TypeName: "ssh_connection", Nested: hcldec.ObjectSpec((*FlatAnsibleConfigConnection)(nil).HCL2Spec())},
	}
	return s
}

// FlatAnsibleConfigConnection is an auto-generated flat version of AnsibleConfigConnection.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatAnsibleConfigConnection struct {
	SSHTimeout *int  `mapstructure:"ssh_timeout" cty:"ssh_timeout" hcl:"ssh_timeout"`
	Pipelining *bool `mapstructure:"pipelining" cty:"pipelining" hcl:"pipelining"`
}

// FlatMapstructure returns a new FlatAnsibleConfigConnection.
// FlatAnsibleConfigConnection is an auto-generated flat version of AnsibleConfigConnection.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*AnsibleConfigConnection) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatAnsibleConfigConnection)
}

// HCL2Spec returns the hcl spec of a AnsibleConfigConnection.
// This spec is used by HCL to read the fields of AnsibleConfigConnection.
// The decoded values from this spec will then be applied to a FlatAnsibleConfigConnection.
func (*FlatAnsibleConfigConnection) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"ssh_timeout": &hcldec.AttrSpec{Name: "ssh_timeout", Type: cty.Number, Required: false},
		"pipelining":  &hcldec.AttrSpec{Name: "pipelining", Type: cty.Bool, Required: false},
	}
	return s
}

// FlatAnsibleConfigDefaults is an auto-generated flat version of AnsibleConfigDefaults.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatAnsibleConfigDefaults struct {
	RemoteTmp       *string `mapstructure:"remote_tmp" cty:"remote_tmp" hcl:"remote_tmp"`
	HostKeyChecking *bool   `mapstructure:"host_key_checking" cty:"host_key_checking" hcl:"host_key_checking"`
}

// FlatMapstructure returns a new FlatAnsibleConfigDefaults.
// FlatAnsibleConfigDefaults is an auto-generated flat version of AnsibleConfigDefaults.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*AnsibleConfigDefaults) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatAnsibleConfigDefaults)
}

// HCL2Spec returns the hcl spec of a AnsibleConfigDefaults.
// This spec is used by HCL to read the fields of AnsibleConfigDefaults.
// The decoded values from this spec will then be applied to a FlatAnsibleConfigDefaults.
func (*FlatAnsibleConfigDefaults) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"remote_tmp":        &hcldec.AttrSpec{Name: "remote_tmp", Type: cty.String, Required: false},
		"host_key_checking": &hcldec.AttrSpec{Name: "host_key_checking", Type: cty.Bool, Required: false},
	}
	return s
}

// FlatCollectionDocCache is an auto-generated flat version of CollectionDocCache.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatCollectionDocCache struct {
	Path    *string `mapstructure:"path" cty:"path" hcl:"path"`
	Timeout *int    `mapstructure:"timeout" cty:"timeout" hcl:"timeout"`
}

// FlatMapstructure returns a new FlatCollectionDocCache.
// FlatCollectionDocCache is an auto-generated flat version of CollectionDocCache.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*CollectionDocCache) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatCollectionDocCache)
}

// HCL2Spec returns the hcl spec of a CollectionDocCache.
// This spec is used by HCL to read the fields of CollectionDocCache.
// The decoded values from this spec will then be applied to a FlatCollectionDocCache.
func (*FlatCollectionDocCache) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"path":    &hcldec.AttrSpec{Name: "path", Type: cty.String, Required: false},
		"timeout": &hcldec.AttrSpec{Name: "timeout", Type: cty.Number, Required: false},
	}
	return s
}

// FlatConfig is an auto-generated flat version of Config.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatConfig struct {
	PackerBuildName         *string              `mapstructure:"packer_build_name" cty:"packer_build_name" hcl:"packer_build_name"`
	PackerBuilderType       *string              `mapstructure:"packer_builder_type" cty:"packer_builder_type" hcl:"packer_builder_type"`
	PackerCoreVersion       *string              `mapstructure:"packer_core_version" cty:"packer_core_version" hcl:"packer_core_version"`
	PackerDebug             *bool                `mapstructure:"packer_debug" cty:"packer_debug" hcl:"packer_debug"`
	PackerForce             *bool                `mapstructure:"packer_force" cty:"packer_force" hcl:"packer_force"`
	PackerOnError           *string              `mapstructure:"packer_on_error" cty:"packer_on_error" hcl:"packer_on_error"`
	PackerUserVars          map[string]string    `mapstructure:"packer_user_variables" cty:"packer_user_variables" hcl:"packer_user_variables"`
	PackerSensitiveVars     []string             `mapstructure:"packer_sensitive_variables" cty:"packer_sensitive_variables" hcl:"packer_sensitive_variables"`
	Command                 *string              `mapstructure:"command" cty:"command" hcl:"command"`
	AnsibleNavigatorPath    []string             `mapstructure:"ansible_navigator_path" cty:"ansible_navigator_path" hcl:"ansible_navigator_path"`
	KeepGoing               *bool                `mapstructure:"keep_going" cty:"keep_going" hcl:"keep_going"`
	StructuredLogging       *bool                `mapstructure:"structured_logging" cty:"structured_logging" hcl:"structured_logging"`
	LogOutputPath           *string              `mapstructure:"log_output_path" cty:"log_output_path" hcl:"log_output_path"`
	VerboseTaskOutput       *bool                `mapstructure:"verbose_task_output" cty:"verbose_task_output" hcl:"verbose_task_output"`
	Plays                   []FlatPlay           `mapstructure:"play" cty:"play" hcl:"play"`
	RequirementsFile        *string              `mapstructure:"requirements_file" cty:"requirements_file" hcl:"requirements_file"`
	RolesPath               *string              `mapstructure:"roles_path" cty:"roles_path" hcl:"roles_path"`
	CollectionsPath         *string              `mapstructure:"collections_path" cty:"collections_path" hcl:"collections_path"`
	OfflineMode             *bool                `mapstructure:"offline_mode" cty:"offline_mode" hcl:"offline_mode"`
	GalaxyCommand           *string              `mapstructure:"galaxy_command" cty:"galaxy_command" hcl:"galaxy_command"`
	GalaxyArgs              []string             `mapstructure:"galaxy_args" cty:"galaxy_args" hcl:"galaxy_args"`
	GalaxyForce             *bool                `mapstructure:"galaxy_force" cty:"galaxy_force" hcl:"galaxy_force"`
	Groups                  []string             `mapstructure:"groups" cty:"groups" hcl:"groups"`
	EmptyGroups             []string             `mapstructure:"empty_groups" cty:"empty_groups" hcl:"empty_groups"`
	HostAlias               *string              `mapstructure:"host_alias" cty:"host_alias" hcl:"host_alias"`
	User                    *string              `mapstructure:"user" cty:"user" hcl:"user"`
	LocalPort               *int                 `mapstructure:"local_port" cty:"local_port" hcl:"local_port"`
	SSHHostKeyFile          *string              `mapstructure:"ssh_host_key_file" cty:"ssh_host_key_file" hcl:"ssh_host_key_file"`
	SSHAuthorizedKeyFile    *string              `mapstructure:"ssh_authorized_key_file" cty:"ssh_authorized_key_file" hcl:"ssh_authorized_key_file"`
	AdapterKeyType          *string              `mapstructure:"ansible_proxy_key_type" cty:"ansible_proxy_key_type" hcl:"ansible_proxy_key_type"`
	AnsibleProxyBindAddress *string              `mapstructure:"ansible_proxy_bind_address" cty:"ansible_proxy_bind_address" hcl:"ansible_proxy_bind_address"`
	AnsibleProxyHost        *string              `mapstructure:"ansible_proxy_host" cty:"ansible_proxy_host" hcl:"ansible_proxy_host"`
	SFTPCmd                 *string              `mapstructure:"sftp_command" cty:"sftp_command" hcl:"sftp_command"`
	SkipVersionCheck        *bool                `mapstructure:"skip_version_check" cty:"skip_version_check" hcl:"skip_version_check"`
	VersionCheckTimeout     *string              `mapstructure:"version_check_timeout" cty:"version_check_timeout" hcl:"version_check_timeout"`
	UseSFTP                 *bool                `mapstructure:"use_sftp" cty:"use_sftp" hcl:"use_sftp"`
	InventoryDirectory      *string              `mapstructure:"inventory_directory" cty:"inventory_directory" hcl:"inventory_directory"`
	InventoryFileTemplate   *string              `mapstructure:"inventory_file_template" cty:"inventory_file_template" hcl:"inventory_file_template"`
	InventoryFile           *string              `mapstructure:"inventory_file" cty:"inventory_file" hcl:"inventory_file"`
	Limit                   *string              `mapstructure:"limit" cty:"limit" hcl:"limit"`
	KeepInventoryFile       *bool                `mapstructure:"keep_inventory_file" cty:"keep_inventory_file" hcl:"keep_inventory_file"`
	GalaxyForceWithDeps     *bool                `mapstructure:"galaxy_force_with_deps" cty:"galaxy_force_with_deps" hcl:"galaxy_force_with_deps"`
	UseProxy                *bool                `mapstructure:"use_proxy" cty:"use_proxy" hcl:"use_proxy"`
	WinRMUseHTTP            *bool                `mapstructure:"ansible_winrm_use_http" cty:"ansible_winrm_use_http" hcl:"ansible_winrm_use_http"`
	NavigatorConfig         *FlatNavigatorConfig `mapstructure:"navigator_config" cty:"navigator_config" hcl:"navigator_config"`
}

// FlatMapstructure returns a new FlatConfig.
// FlatConfig is an auto-generated flat version of Config.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*Config) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatConfig)
}

// HCL2Spec returns the hcl spec of a Config.
// This spec is used by HCL to read the fields of Config.
// The decoded values from this spec will then be applied to a FlatConfig.
func (*FlatConfig) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"packer_build_name":          &hcldec.AttrSpec{Name: "packer_build_name", Type: cty.String, Required: false},
		"packer_builder_type":        &hcldec.AttrSpec{Name: "packer_builder_type", Type: cty.String, Required: false},
		"packer_core_version":        &hcldec.AttrSpec{Name: "packer_core_version", Type: cty.String, Required: false},
		"packer_debug":               &hcldec.AttrSpec{Name: "packer_debug", Type: cty.Bool, Required: false},
		"packer_force":               &hcldec.AttrSpec{Name: "packer_force", Type: cty.Bool, Required: false},
		"packer_on_error":            &hcldec.AttrSpec{Name: "packer_on_error", Type: cty.String, Required: false},
		"packer_user_variables":      &hcldec.AttrSpec{Name: "packer_user_variables", Type: cty.Map(cty.String), Required: false},
		"packer_sensitive_variables": &hcldec.AttrSpec{Name: "packer_sensitive_variables", Type: cty.List(cty.String), Required: false},
		"command":                    &hcldec.AttrSpec{Name: "command", Type: cty.String, Required: false},
		"ansible_navigator_path":     &hcldec.AttrSpec{Name: "ansible_navigator_path", Type: cty.List(cty.String), Required: false},
		"keep_going":                 &hcldec.AttrSpec{Name: "keep_going", Type: cty.Bool, Required: false},
		"structured_logging":         &hcldec.AttrSpec{Name: "structured_logging", Type: cty.Bool, Required: false},
		"log_output_path":            &hcldec.AttrSpec{Name: "log_output_path", Type: cty.String, Required: false},
		"verbose_task_output":        &hcldec.AttrSpec{Name: "verbose_task_output", Type: cty.Bool, Required: false},
		"play":                       &hcldec.BlockListSpec{TypeName: "play", Nested: hcldec.ObjectSpec((*FlatPlay)(nil).HCL2Spec())},
		"requirements_file":          &hcldec.AttrSpec{Name: "requirements_file", Type: cty.String, Required: false},
		"roles_path":                 &hcldec.AttrSpec{Name: "roles_path", Type: cty.String, Required: false},
		"collections_path":           &hcldec.AttrSpec{Name: "collections_path", Type: cty.String, Required: false},
		"offline_mode":               &hcldec.AttrSpec{Name: "offline_mode", Type: cty.Bool, Required: false},
		"galaxy_command":             &hcldec.AttrSpec{Name: "galaxy_command", Type: cty.String, Required: false},
		"galaxy_args":                &hcldec.AttrSpec{Name: "galaxy_args", Type: cty.List(cty.String), Required: false},
		"galaxy_force":               &hcldec.AttrSpec{Name: "galaxy_force", Type: cty.Bool, Required: false},
		"groups":                     &hcldec.AttrSpec{Name: "groups", Type: cty.List(cty.String), Required: false},
		"empty_groups":               &hcldec.AttrSpec{Name: "empty_groups", Type: cty.List(cty.String), Required: false},
		"host_alias":                 &hcldec.AttrSpec{Name: "host_alias", Type: cty.String, Required: false},
		"user":                       &hcldec.AttrSpec{Name: "user", Type: cty.String, Required: false},
		"local_port":                 &hcldec.AttrSpec{Name: "local_port", Type: cty.Number, Required: false},
		"ssh_host_key_file":          &hcldec.AttrSpec{Name: "ssh_host_key_file", Type: cty.String, Required: false},
		"ssh_authorized_key_file":    &hcldec.AttrSpec{Name: "ssh_authorized_key_file", Type: cty.String, Required: false},
		"ansible_proxy_key_type":     &hcldec.AttrSpec{Name: "ansible_proxy_key_type", Type: cty.String, Required: false},
		"ansible_proxy_bind_address": &hcldec.AttrSpec{Name: "ansible_proxy_bind_address", Type: cty.String, Required: false},
		"ansible_proxy_host":         &hcldec.AttrSpec{Name: "ansible_proxy_host", Type: cty.String, Required: false},
		"sftp_command":               &hcldec.AttrSpec{Name: "sftp_command", Type: cty.String, Required: false},
		"skip_version_check":         &hcldec.AttrSpec{Name: "skip_version_check", Type: cty.Bool, Required: false},
		"version_check_timeout":      &hcldec.AttrSpec{Name: "version_check_timeout", Type: cty.String, Required: false},
		"use_sftp":                   &hcldec.AttrSpec{Name: "use_sftp", Type: cty.Bool, Required: false},
		"inventory_directory":        &hcldec.AttrSpec{Name: "inventory_directory", Type: cty.String, Required: false},
		"inventory_file_template":    &hcldec.AttrSpec{Name: "inventory_file_template", Type: cty.String, Required: false},
		"inventory_file":             &hcldec.AttrSpec{Name: "inventory_file", Type: cty.String, Required: false},
		"limit":                      &hcldec.AttrSpec{Name: "limit", Type: cty.String, Required: false},
		"keep_inventory_file":        &hcldec.AttrSpec{Name: "keep_inventory_file", Type: cty.Bool, Required: false},
		"galaxy_force_with_deps":     &hcldec.AttrSpec{Name: "galaxy_force_with_deps", Type: cty.Bool, Required: false},
		"use_proxy":                  &hcldec.AttrSpec{Name: "use_proxy", Type: cty.Bool, Required: false},
		"ansible_winrm_use_http":     &hcldec.AttrSpec{Name: "ansible_winrm_use_http", Type: cty.Bool, Required: false},
		"navigator_config":           &hcldec.BlockSpec{TypeName: "navigator_config", Nested: hcldec.ObjectSpec((*FlatNavigatorConfig)(nil).HCL2Spec())},
	}
	return s
}

// FlatEnvironmentVariablesConfig is an auto-generated flat version of EnvironmentVariablesConfig.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatEnvironmentVariablesConfig struct {
	Pass []string          `mapstructure:"pass" cty:"pass" hcl:"pass"`
	Set  map[string]string `mapstructure:"set" cty:"set" hcl:"set"`
}

// FlatMapstructure returns a new FlatEnvironmentVariablesConfig.
// FlatEnvironmentVariablesConfig is an auto-generated flat version of EnvironmentVariablesConfig.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*EnvironmentVariablesConfig) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatEnvironmentVariablesConfig)
}

// HCL2Spec returns the hcl spec of a EnvironmentVariablesConfig.
// This spec is used by HCL to read the fields of EnvironmentVariablesConfig.
// The decoded values from this spec will then be applied to a FlatEnvironmentVariablesConfig.
func (*FlatEnvironmentVariablesConfig) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"pass": &hcldec.AttrSpec{Name: "pass", Type: cty.List(cty.String), Required: false},
		"set":  &hcldec.AttrSpec{Name: "set", Type: cty.Map(cty.String), Required: false},
	}
	return s
}

// FlatExecutionEnvironment is an auto-generated flat version of ExecutionEnvironment.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatExecutionEnvironment struct {
	Enabled              *bool                           `mapstructure:"enabled" cty:"enabled" hcl:"enabled"`
	Image                *string                         `mapstructure:"image" cty:"image" hcl:"image"`
	PullPolicy           *string                         `mapstructure:"pull_policy" cty:"pull_policy" hcl:"pull_policy"`
	EnvironmentVariables *FlatEnvironmentVariablesConfig `mapstructure:"environment_variables" cty:"environment_variables" hcl:"environment_variables"`
}

// FlatMapstructure returns a new FlatExecutionEnvironment.
// FlatExecutionEnvironment is an auto-generated flat version of ExecutionEnvironment.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*ExecutionEnvironment) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatExecutionEnvironment)
}

// HCL2Spec returns the hcl spec of a ExecutionEnvironment.
// This spec is used by HCL to read the fields of ExecutionEnvironment.
// The decoded values from this spec will then be applied to a FlatExecutionEnvironment.
func (*FlatExecutionEnvironment) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"enabled":               &hcldec.AttrSpec{Name: "enabled", Type: cty.Bool, Required: false},
		"image":                 &hcldec.AttrSpec{Name: "image", Type: cty.String, Required: false},
		"pull_policy":           &hcldec.AttrSpec{Name: "pull_policy", Type: cty.String, Required: false},
		"environment_variables": &hcldec.BlockSpec{TypeName: "environment_variables", Nested: hcldec.ObjectSpec((*FlatEnvironmentVariablesConfig)(nil).HCL2Spec())},
	}
	return s
}

// FlatLoggingConfig is an auto-generated flat version of LoggingConfig.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatLoggingConfig struct {
	Level  *string `mapstructure:"level" cty:"level" hcl:"level"`
	File   *string `mapstructure:"file" cty:"file" hcl:"file"`
	Append *bool   `mapstructure:"append" cty:"append" hcl:"append"`
}

// FlatMapstructure returns a new FlatLoggingConfig.
// FlatLoggingConfig is an auto-generated flat version of LoggingConfig.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*LoggingConfig) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatLoggingConfig)
}

// HCL2Spec returns the hcl spec of a LoggingConfig.
// This spec is used by HCL to read the fields of LoggingConfig.
// The decoded values from this spec will then be applied to a FlatLoggingConfig.
func (*FlatLoggingConfig) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"level":  &hcldec.AttrSpec{Name: "level", Type: cty.String, Required: false},
		"file":   &hcldec.AttrSpec{Name: "file", Type: cty.String, Required: false},
		"append": &hcldec.AttrSpec{Name: "append", Type: cty.Bool, Required: false},
	}
	return s
}

// FlatNavigatorConfig is an auto-generated flat version of NavigatorConfig.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatNavigatorConfig struct {
	Mode                 *string                   `mapstructure:"mode" cty:"mode" hcl:"mode"`
	ExecutionEnvironment *FlatExecutionEnvironment `mapstructure:"execution_environment" cty:"execution_environment" hcl:"execution_environment"`
	AnsibleConfig        *FlatAnsibleConfig        `mapstructure:"ansible_config" cty:"ansible_config" hcl:"ansible_config"`
	Logging              *FlatLoggingConfig        `mapstructure:"logging" cty:"logging" hcl:"logging"`
	PlaybookArtifact     *FlatPlaybookArtifact     `mapstructure:"playbook_artifact" cty:"playbook_artifact" hcl:"playbook_artifact"`
	CollectionDocCache   *FlatCollectionDocCache   `mapstructure:"collection_doc_cache" cty:"collection_doc_cache" hcl:"collection_doc_cache"`
}

// FlatMapstructure returns a new FlatNavigatorConfig.
// FlatNavigatorConfig is an auto-generated flat version of NavigatorConfig.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*NavigatorConfig) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatNavigatorConfig)
}

// HCL2Spec returns the hcl spec of a NavigatorConfig.
// This spec is used by HCL to read the fields of NavigatorConfig.
// The decoded values from this spec will then be applied to a FlatNavigatorConfig.
func (*FlatNavigatorConfig) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"mode":                  &hcldec.AttrSpec{Name: "mode", Type: cty.String, Required: false},
		"execution_environment": &hcldec.BlockSpec{TypeName: "execution_environment", Nested: hcldec.ObjectSpec((*FlatExecutionEnvironment)(nil).HCL2Spec())},
		"ansible_config":        &hcldec.BlockSpec{TypeName: "ansible_config", Nested: hcldec.ObjectSpec((*FlatAnsibleConfig)(nil).HCL2Spec())},
		"logging":               &hcldec.BlockSpec{TypeName: "logging", Nested: hcldec.ObjectSpec((*FlatLoggingConfig)(nil).HCL2Spec())},
		"playbook_artifact":     &hcldec.BlockSpec{TypeName: "playbook_artifact", Nested: hcldec.ObjectSpec((*FlatPlaybookArtifact)(nil).HCL2Spec())},
		"collection_doc_cache":  &hcldec.BlockSpec{TypeName: "collection_doc_cache", Nested: hcldec.ObjectSpec((*FlatCollectionDocCache)(nil).HCL2Spec())},
	}
	return s
}

// FlatPlay is an auto-generated flat version of Play.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatPlay struct {
	Name       *string           `mapstructure:"name" cty:"name" hcl:"name"`
	Target     *string           `mapstructure:"target" cty:"target" hcl:"target"`
	ExtraVars  map[string]string `mapstructure:"extra_vars" cty:"extra_vars" hcl:"extra_vars"`
	Tags       []string          `mapstructure:"tags" cty:"tags" hcl:"tags"`
	VarsFiles  []string          `mapstructure:"vars_files" cty:"vars_files" hcl:"vars_files"`
	Become     *bool             `mapstructure:"become" cty:"become" hcl:"become"`
	BecomeUser *string           `mapstructure:"become_user" cty:"become_user" hcl:"become_user"`
	SkipTags   []string          `mapstructure:"skip_tags" cty:"skip_tags" hcl:"skip_tags"`
}

// FlatMapstructure returns a new FlatPlay.
// FlatPlay is an auto-generated flat version of Play.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*Play) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatPlay)
}

// HCL2Spec returns the hcl spec of a Play.
// This spec is used by HCL to read the fields of Play.
// The decoded values from this spec will then be applied to a FlatPlay.
func (*FlatPlay) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"name":        &hcldec.AttrSpec{Name: "name", Type: cty.String, Required: false},
		"target":      &hcldec.AttrSpec{Name: "target", Type: cty.String, Required: false},
		"extra_vars":  &hcldec.AttrSpec{Name: "extra_vars", Type: cty.Map(cty.String), Required: false},
		"tags":        &hcldec.AttrSpec{Name: "tags", Type: cty.List(cty.String), Required: false},
		"vars_files":  &hcldec.AttrSpec{Name: "vars_files", Type: cty.List(cty.String), Required: false},
		"become":      &hcldec.AttrSpec{Name: "become", Type: cty.Bool, Required: false},
		"become_user": &hcldec.AttrSpec{Name: "become_user", Type: cty.String, Required: false},
		"skip_tags":   &hcldec.AttrSpec{Name: "skip_tags", Type: cty.List(cty.String), Required: false},
	}
	return s
}

// FlatPlaybookArtifact is an auto-generated flat version of PlaybookArtifact.
// Where the contents of a field with a `mapstructure:,squash` tag are bubbled up.
type FlatPlaybookArtifact struct {
	Enable *bool   `mapstructure:"enable" cty:"enable" hcl:"enable"`
	Replay *string `mapstructure:"replay" cty:"replay" hcl:"replay"`
	SaveAs *string `mapstructure:"save_as" cty:"save_as" hcl:"save_as"`
}

// FlatMapstructure returns a new FlatPlaybookArtifact.
// FlatPlaybookArtifact is an auto-generated flat version of PlaybookArtifact.
// Where the contents a fields with a `mapstructure:,squash` tag are bubbled up.
func (*PlaybookArtifact) FlatMapstructure() interface{ HCL2Spec() map[string]hcldec.Spec } {
	return new(FlatPlaybookArtifact)
}

// HCL2Spec returns the hcl spec of a PlaybookArtifact.
// This spec is used by HCL to read the fields of PlaybookArtifact.
// The decoded values from this spec will then be applied to a FlatPlaybookArtifact.
func (*FlatPlaybookArtifact) HCL2Spec() map[string]hcldec.Spec {
	s := map[string]hcldec.Spec{
		"enable":  &hcldec.AttrSpec{Name: "enable", Type: cty.Bool, Required: false},
		"replay":  &hcldec.AttrSpec{Name: "replay", Type: cty.String, Required: false},
		"save_as": &hcldec.AttrSpec{Name: "save_as", Type: cty.String, Required: false},
	}
	return s
}
